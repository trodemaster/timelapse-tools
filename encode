#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'
shopt -s nullglob
shopt -s nocaseglob

# test for ffmpeg in the path
if ! hash "ffmpeg" >/dev/null 2>&1; then
  echo "Error: ffmpeg not found in path"
  exit 1
fi

# test for jpeginfo binary
if ! hash "jpeginfo" >/dev/null 2>&1; then
  echo "Error: missing jpeginfo command"
  exit 1
fi

# Define global variables and set defaults
INPUT_PATH="$PWD"
OUTPUT_PATH="$PWD/encoded.mp4"
ENCODE_ARCHIVE=1
HD_ARCHIVE=1
JPEG_EXT="none"
BADPEG=1

# print out usage
usage() {
  cat <<EOF
USAGE: ./encode -p /Volumes/fast/timelapseSource -o /Volumes/fast/timelapseArchive.mp4
OPTIONS:
   -p    Path to source images
   -b    Search for bad jpeg files and delete them without warning
   -o    Path to output file including extension
   -a    Encode with archive format
   -d    Encode with HD 1080p 60fps
   -h    Help
EOF
  exit
}

# process options and arguments
while getopts "bp:o:adh" OPTION; do
  case $OPTION in
  h) usage && exit 1 ;;
  p) INPUT_PATH=$OPTARG ;;
  o) OUTPUT_PATH=$OPTARG ;;
  a) ENCODE_ARCHIVE=0 ;;
  d) HD_ARCHIVE=0 ;;
  b) BADPEG=0 ;;
  esac
done

# test for the provided path
if ! [[ -d $INPUT_PATH ]]; then
  echo "Error: path not found! ${INPUT_PATH}"
  exit 1
fi

## get the first jpg file in the provided path and get details on it
get_info() {
  FIRST_JPG=$(find ${INPUT_PATH} -maxdepth 1 -name '*.JPG' -o -name '*.jpg' -o -name '*.mp4' -o -name '*.MP4' -o -name '*.mkv' -o -name '*.MKV' | head -n 1) || true
  if [[ -f "$FIRST_JPG" ]]; then
    jpeginfo -i "$FIRST_JPG"
    JPEG_EXT=$(rev <<<"$FIRST_JPG" | cut -d '.' -f 1 | rev)
  else
    echo "Error: ${INPUT_PATH}/*.$JPEG_EXT not found!"
    exit 1
  fi
}

get_info
#exit 0

badpeg() {
  # test for jpeginfo binary
  if ! (command -v jpeginfo >/dev/null 2>&1); then
    echo "missing jpeginfo command"
    exit 1
  fi
  echo "Deleting any invalid jpeg files found..."
  # delete bad jpeg files
  find ${INPUT_PATH} -maxdepth 1 -name '*.JPG' -o -name '*.jpg' | xargs jpeginfo -c -q -d - >/dev/null 2>&1 || true
}

archive_encode() {
  ffmpeg -y -r 60 -thread_queue_size 8192 -pattern_type glob -i "${INPUT_PATH}/*.$JPEG_EXT" -vcodec libx264 -crf 26 -tune fastdecode -preset slow -c:v libx265 -pix_fmt yuv420p -tag:v hvc1 ${OUTPUT_PATH}
}

hd_encode() {
  ffmpeg -y -r 30 -thread_queue_size 8192 -pattern_type glob -i "${INPUT_PATH}/*.$JPEG_EXT" -vcodec libx264 -crf 22 -tune fastdecode -vf "scale=iw*min(1920/iw\,1080/ih):ih*min(1920/iw\,1080/ih), pad=1920:1080:(1920-iw*min(1920/iw\,1080/ih))/2:(1080-ih*min(1920/iw\,1080/ih))/2" -preset fast -c:v libx265 -pix_fmt yuv420p -tag:v hvc1 ${OUTPUT_PATH}
}

if [[ $BADPEG == 0 ]]; then
  badpeg
fi

if [[ $ENCODE_ARCHIVE == 0 ]]; then
  archive_encode
  open ${OUTPUT_PATH}
fi

if [[ $HD_ARCHIVE == 0 ]]; then
  hd_encode
  open ${OUTPUT_PATH}
fi

# test for jpegs at the provided path
echo FIN
exit 0
