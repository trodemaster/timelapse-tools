#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'
shopt -s nullglob
shopt -s nocaseglob

# test for ffmpeg in the path
if ! hash "ffmpeg" >/dev/null 2>&1; then
  echo "Error: ffmpeg not found in path"
  exit 1
fi

# test for jpeginfo binary
if ! hash "jpeginfo" >/dev/null 2>&1; then
  echo "Error: missing jpeginfo command"
  exit 1
fi

# Define global variables and set defaults
INPUT_PATH="$PWD"
OUTPUT_PATH="$PWD/encoded.mp4"
ENCODE_ARCHIVE=1
HD_ARCHIVE=1

# print out usage
usage() {
  cat <<EOF
USAGE: ./encode -p /Volumes/fast/timelapseSource -o /Volumes/fast/timelapseArchive.mp4
OPTIONS:
   -p    Path to source images
   -o    Path to output file including extension
   -a    Encode with archive format
   -d    Encode with HD 1080p 60fps
   -h    Help
EOF
  exit
}

# process options and arguments
while getopts "p:o:adh" OPTION; do
  case $OPTION in
  h) usage && exit 1 ;;
  p) INPUT_PATH=$OPTARG ;;
  o) OUTPUT_PATH=$OPTARG ;;
  a) ENCODE_ARCHIVE=0 ;;
  d) HD_ARCHIVE=0 ;;
  esac
done

# test for the provided path
if ! [[ -d $INPUT_PATH ]]; then
  echo "Error: path not found! ${INPUT_PATH}"
  exit 1
fi

## get the first jpg file in the provided path and get details on it
get_info() {
  FIRST_JPG=$(find ${INPUT_PATH} -maxdepth 1 -name '*.JPG' | head -n 1) || true
  if [[ -f "$FIRST_JPG" ]]; then
    jpeginfo -i "$FIRST_JPG"
  else
    echo "Error: ${INPUT_PATH}/*.JPG not found!"
  fi
}

get_info

archive_encode() {
  ffmpeg -y -r 60 -thread_queue_size 8192 -pattern_type glob -i "${INPUT_PATH}/*.JPG" -vcodec libx264 -crf 26 -tune fastdecode -preset slow -c:v libx265 -pix_fmt yuv420p -tag:v hvc1 ${OUTPUT_PATH}
}

hd_encode() {
  ffmpeg -y -r 60 -thread_queue_size 8192 -pattern_type glob -i "${INPUT_PATH}/*.JPG" -vcodec libx264 -crf 22 -tune fastdecode -vf "scale=iw*min(1920/iw\,1080/ih):ih*min(1920/iw\,1080/ih), pad=1920:1080:(1920-iw*min(1920/iw\,1080/ih))/2:(1080-ih*min(1920/iw\,1080/ih))/2" -preset fast -c:v libx265 -pix_fmt yuv420p -tag:v hvc1 ${OUTPUT_PATH}
}


if [[ $ENCODE_ARCHIVE == 0 ]]; then
  archive_encode
  open ${OUTPUT_PATH}
fi


if [[ $HD_ARCHIVE == 0 ]]; then
  hd_encode
  open ${OUTPUT_PATH}
fi

# test for jpegs at the provided path
echo FIN
exit 0
